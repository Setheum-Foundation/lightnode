
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/renproject/lightnode/cacher/cacher.go (86.1%)</option>
				
				<option value="file1">github.com/renproject/lightnode/client/client.go (0.0%)</option>
				
				<option value="file2">github.com/renproject/lightnode/dispatcher/dispatcher.go (85.4%)</option>
				
				<option value="file3">github.com/renproject/lightnode/lightnode.go (0.0%)</option>
				
				<option value="file4">github.com/renproject/lightnode/server/ratelimiter/ratelimiter.go (0.0%)</option>
				
				<option value="file5">github.com/renproject/lightnode/server/server.go (58.8%)</option>
				
				<option value="file6">github.com/renproject/lightnode/store/store.go (0.0%)</option>
				
				<option value="file7">github.com/renproject/lightnode/updater/updater.go (67.7%)</option>
				
				<option value="file8">github.com/renproject/lightnode/validator/validator.go (94.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cacher

import (
        "time"

        lru "github.com/hashicorp/golang-lru"
        "github.com/renproject/darknode/jsonrpc"
        "github.com/renproject/kv"
        "github.com/renproject/lightnode/server"
        "github.com/renproject/phi"
        "github.com/sirupsen/logrus"
        "golang.org/x/crypto/sha3"
)

// ID is a key for a cached response.
type ID [32]byte

func (id ID) String() string <span class="cov8" title="1">{
        return string(id[:32])
}</span>

// Cacher is a task responsible for caching responses for corresponding
// requests. Upon receiving a request (in the current architecture this request
// comes from the `Validator`) it will check its cache to see if it has a
// cached response. If it does, it will write this immediately as a repsonse,
// otherwise it will forward the request on to the `Dispatcher`. Once the
// `Dispatcher` has a response ready, the `Cacher` will store this response in
// its cache with a key derived from the request, and then pass the repsonse
// along to be given to the client. Currently, idempotent requests are stored
// in a LRU cache, and non-idempotent requests are stored in a TTL cache.
type Cacher struct {
        logger     logrus.FieldLogger
        dispatcher phi.Sender

        // TODO: Should these two caches be encapsulated into a single object?
        cache    *lru.Cache
        ttlCache kv.Iterable
}

// New constructs a new `Cacher` as a `phi.Task` which can be `Run()`.
func New(dispatcher phi.Sender, logger logrus.FieldLogger, cap int, ttl time.Duration, opts phi.Options) phi.Task <span class="cov8" title="1">{
        cache, err := lru.New(cap)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("[cacher] cannot create LRU cache: %v", err)
        }</span>
        <span class="cov8" title="1">ttlCache, err := kv.NewTTLCache(kv.NewJSON(kv.NewMemDB()), ttl)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("[cacher] cannot create TTL cache: %v", err)
        }</span>
        <span class="cov8" title="1">return phi.New(&amp;Cacher{logger, dispatcher, cache, ttlCache}, opts)</span>
}

// Handle implements the `phi.Handler` interface.
func (cacher *Cacher) Handle(_ phi.Task, message phi.Message) <span class="cov8" title="1">{
        msg, ok := message.(server.RequestWithResponder)
        if !ok </span><span class="cov0" title="0">{
                cacher.logger.Panicf("[cacher] unexpected message type %T", message)
        }</span>

        <span class="cov8" title="1">params, err := msg.Request.Params.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                cacher.logger.Errorf("[cacher] cannot marshal request to json: %v", err)
        }</span>

        <span class="cov8" title="1">data := append(params, []byte(msg.Request.Method)...)
        reqID := hash(data)

        response, cached := cacher.get(reqID)
        if cached </span><span class="cov8" title="1">{
                msg.Responder &lt;- response
        }</span> else<span class="cov8" title="1"> {
                responder := make(chan jsonrpc.Response, 1)
                cacher.dispatcher.Send(server.RequestWithResponder{
                        Request:   msg.Request,
                        Responder: responder,
                })

                // TODO: What do we do when a second request comes in that is already
                // being fetched at the moment? Currently it will also send it to the
                // dispatcher, which is probably not ideal.
                go func() </span><span class="cov8" title="1">{
                        response := &lt;-responder
                        cacher.insert(reqID, response, msg.Request.Method)
                        msg.Responder &lt;- response
                }</span>()
        }
}

func (cacher *Cacher) insert(id ID, response jsonrpc.Response, method string) <span class="cov8" title="1">{
        // It is assumed at this point that the method is valid, so we can safely
        // avoid the case of undefined methods.
        if method != jsonrpc.MethodSubmitTx </span><span class="cov8" title="1">{
                if err := cacher.ttlCache.Insert(id.String(), response); err != nil </span><span class="cov0" title="0">{
                        cacher.logger.Panicf("[cacher] could not insert response into TTL cache: %v", err)
                }</span>
        } else<span class="cov8" title="1"> {
                cacher.cache.Add(id, response)
        }</span>
}

func (cacher *Cacher) get(id ID) (jsonrpc.Response, bool) <span class="cov8" title="1">{
        if response, ok := cacher.cache.Get(id); ok </span><span class="cov8" title="1">{
                return response.(jsonrpc.Response), true
        }</span>

        <span class="cov8" title="1">var response jsonrpc.Response
        if err := cacher.ttlCache.Get(id.String(), &amp;response); err == nil </span><span class="cov8" title="1">{
                return response, true
        }</span>

        <span class="cov8" title="1">return jsonrpc.Response{}, false</span>
}

func hash(data []byte) ID <span class="cov8" title="1">{
        return sha3.Sum256(data)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package client

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/renproject/darknode/addr"
        "github.com/renproject/darknode/jsonrpc"
)

// SendToDarknode sends a given request to the darknode at the given url. The
// timeout is the timeout for the request.
//
// NOTE: If err is not nil, it is expected that the caller will construct an
// appropriate error response message.
func SendToDarknode(url string, req jsonrpc.Request, timeout time.Duration) (jsonrpc.Response, error) <span class="cov0" title="0">{
        httpClient := new(http.Client)
        httpClient.Timeout = timeout

        // Construct HTTP request.
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("[client] could not marshal request: %v", err))</span>
        }
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), httpClient.Timeout)
        defer cancel()
        r, err := http.NewRequest(http.MethodPost, url, bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("[client] could not create http request: %v", err))</span>
        }
        <span class="cov0" title="0">r = r.WithContext(ctx)
        r.Header.Set("Content-Type", "application/json")

        // Read response.
        response, err := httpClient.Do(r)
        if err != nil </span><span class="cov0" title="0">{
                return jsonrpc.Response{}, err
        }</span>

        <span class="cov0" title="0">var resp jsonrpc.Response
        err = json.NewDecoder(response.Body).Decode(&amp;resp)
        return resp, err</span>
}

// URLFromMulti converts a `addr.MultiAddress` to a url string appropriate for
// sending a JSON-RPC request to a darknode. The port is defined in the multi
// address is incremented by one because of darknode specific logic about what
// the JSON-RPC port is.
func URLFromMulti(addr addr.MultiAddress) string <span class="cov0" title="0">{
        return fmt.Sprintf("http://%s:%v", addr.IP4(), addr.Port()+1)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package dispatcher

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/renproject/darknode/addr"
        "github.com/renproject/darknode/jsonrpc"
        "github.com/renproject/lightnode/client"
        "github.com/renproject/lightnode/server"
        "github.com/renproject/lightnode/store"
        "github.com/renproject/phi"
        "github.com/sirupsen/logrus"
)

// A Dispatcher is a task that is responsible for taking a request, sending it
// to a subset of the darknodes, waiting for the corresponding results, and the
// finally aggregating the results into a single result to be returned to the
// client of the lightnode. The addresses of known darknodes are stored in a
// store that is shared by the `Updater`, which will periodically update the
// store so that the addresses of the known darkndoes are kept up to date.
type Dispatcher struct {
        logger     logrus.FieldLogger
        timeout    time.Duration
        multiStore store.MultiAddrStore
}

// New constructs a new `Dispatcher`.
func New(logger logrus.FieldLogger, timeout time.Duration, multiStore store.MultiAddrStore, opts phi.Options) phi.Task <span class="cov8" title="1">{
        return phi.New(
                &amp;Dispatcher{
                        logger:     logger,
                        timeout:    timeout,
                        multiStore: multiStore,
                },
                opts,
        )
}</span>

// Handle implements the `phi.Handler` interface.
func (dispatcher *Dispatcher) Handle(_ phi.Task, message phi.Message) <span class="cov8" title="1">{
        msg, ok := message.(server.RequestWithResponder)
        if !ok </span><span class="cov0" title="0">{
                dispatcher.logger.Panicf("[dispatcher] unexpected message type %T", message)
        }</span>

        <span class="cov8" title="1">addrs := dispatcher.multiAddrs(msg.Request.Method)
        responses := make(chan jsonrpc.Response, len(addrs))
        resIter := newResponseIter(msg.Request.Method)

        go func() </span><span class="cov8" title="1">{
                phi.ParForAll(addrs, func(i int) </span><span class="cov8" title="1">{
                        response, err := client.SendToDarknode(client.URLFromMulti(addrs[i]), msg.Request, dispatcher.timeout)
                        if err != nil </span><span class="cov8" title="1">{
                                errMsg := fmt.Sprintf("lightnode could not forward response to darknode: %v", err)
                                err := jsonrpc.NewError(server.ErrorCodeForwardingError, errMsg, json.RawMessage{})
                                response := jsonrpc.NewResponse(0, nil, &amp;err)
                                responses &lt;- response
                        }</span> else<span class="cov8" title="1"> {
                                responses &lt;- response
                        }</span>
                })
                <span class="cov8" title="1">close(responses)</span>
        }()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                i := 1
                for res := range responses </span><span class="cov8" title="1">{
                        done, response := resIter.update(res, i == len(addrs))
                        if done </span><span class="cov8" title="1">{
                                msg.Responder &lt;- response
                                return
                        }</span>
                        <span class="cov0" title="0">i++</span>
                }
        }()
}

func (dispatcher *Dispatcher) multiAddrs(method string) addr.MultiAddresses <span class="cov8" title="1">{
        // The method `Size` for a `memdb` always returns a nil error, so we ignore
        // it
        // NOTE: This is commented out for now but address selection policies used
        // in the future should make use of this number.
        // numDarknodes, _ := dispatcher.multiStore.Size()

        // TODO: The following is an initial choice of darknode selection policies,
        // which are likely to not be what we use long term. These should be
        // updated when these policies have been decided in more detail.
        switch method </span>{
        case jsonrpc.MethodQueryBlock:<span class="cov8" title="1">
                return dispatcher.multiStore.AddrsRandom(3)</span>
        case jsonrpc.MethodQueryBlocks:<span class="cov8" title="1">
                return dispatcher.multiStore.AddrsRandom(3)</span>
        case jsonrpc.MethodSubmitTx:<span class="cov8" title="1">
                return dispatcher.multiStore.AddrsAll()</span>
        case jsonrpc.MethodQueryTx:<span class="cov8" title="1">
                return dispatcher.multiStore.AddrsRandom(3)</span>
        case jsonrpc.MethodQueryNumPeers:<span class="cov8" title="1">
                return dispatcher.multiStore.AddrsRandom(3)</span>
        case jsonrpc.MethodQueryPeers:<span class="cov8" title="1">
                return dispatcher.multiStore.AddrsRandom(3)</span>
        case jsonrpc.MethodQueryEpoch:<span class="cov0" title="0">
                return dispatcher.multiStore.AddrsRandom(3)</span>
        case jsonrpc.MethodQueryStat:<span class="cov8" title="1">
                return dispatcher.multiStore.AddrsRandom(3)</span>
        default:<span class="cov0" title="0">
                dispatcher.logger.Panicf("[dispatcher] unsupported method %s encountered which should have been rejected by the validator", method)
                panic("unreachable")</span>
        }
}

func newResponseIter(method string) responseIterator <span class="cov8" title="1">{
        // TODO: The following is an initial choice of response aggregation
        // policies, which are likely to not be what we use long term. These should
        // be updated when these policies have been decided in more detail.
        switch method </span>{
        case jsonrpc.MethodQueryBlock:<span class="cov8" title="1">
                return newFirstResponseIterator()</span>
        case jsonrpc.MethodQueryBlocks:<span class="cov8" title="1">
                return newFirstResponseIterator()</span>
        case jsonrpc.MethodSubmitTx:<span class="cov8" title="1">
                // TODO: This should instead return an iterator that will check for a
                // threshold of consistent responses.
                return newFirstResponseIterator()</span>
        case jsonrpc.MethodQueryTx:<span class="cov8" title="1">
                return newFirstResponseIterator()</span>
        case jsonrpc.MethodQueryNumPeers:<span class="cov8" title="1">
                return newFirstResponseIterator()</span>
        case jsonrpc.MethodQueryPeers:<span class="cov8" title="1">
                return newFirstResponseIterator()</span>
        case jsonrpc.MethodQueryEpoch:<span class="cov0" title="0">
                return newFirstResponseIterator()</span>
        case jsonrpc.MethodQueryStat:<span class="cov8" title="1">
                return newFirstResponseIterator()</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("[dispatcher] unsupported method %s encountered which should have been rejected by the validator", method))</span>
        }
}

type responseIterator interface {
        update(jsonrpc.Response, bool) (bool, jsonrpc.Response)
}

type firstResponseIterator struct{}

func newFirstResponseIterator() responseIterator <span class="cov8" title="1">{
        return firstResponseIterator{}
}</span>

func (firstResponseIterator) update(res jsonrpc.Response, final bool) (bool, jsonrpc.Response) <span class="cov8" title="1">{
        return true, res
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package lightnode

import (
        "context"
        "time"

        "github.com/renproject/darknode/addr"
        "github.com/renproject/kv"
        "github.com/renproject/lightnode/cacher"
        "github.com/renproject/lightnode/dispatcher"
        "github.com/renproject/lightnode/server"
        "github.com/renproject/lightnode/store"
        "github.com/renproject/lightnode/updater"
        "github.com/renproject/lightnode/validator"
        "github.com/renproject/phi"
        "github.com/sirupsen/logrus"
)

// Lightnode is the top level container that encapsulates the functionality of
// the lightnode.
type Lightnode struct {
        logger logrus.FieldLogger
        server *server.Server

        // Tasks
        validator  phi.Task
        cacher     phi.Task
        dispatcher phi.Task

        updater updater.Updater
}

// New constructs a new `Lightnode`.
func New(logger logrus.FieldLogger, timeout time.Duration, cap, cacheCap int, port string, maxBatchSize int, bootstrapAddrs addr.MultiAddresses, pollRate, ttl time.Duration) Lightnode <span class="cov0" title="0">{
        // All tasks have the same capacity, and no scaling
        opts := phi.Options{Cap: cap}

        // Server options
        options := server.Options{MaxBatchSize: maxBatchSize}

        // TODO: Insert the bootstrap addresses into the store first.
        multiStore := store.New(kv.NewMemDB())

        updater := updater.New(logger, multiStore, pollRate, timeout)
        dispatcher := dispatcher.New(logger, timeout, multiStore, opts)
        cacher := cacher.New(dispatcher, logger, cacheCap, ttl, opts)
        validator := validator.New(cacher, logger, opts)
        server := server.New(logger, port, options, validator)

        return Lightnode{
                logger,
                server,
                validator,
                cacher,
                dispatcher,
                updater,
        }
}</span>

// Run starts the `Lightnode`. This function call is blocking.
func (lightnode Lightnode) Run(ctx context.Context) <span class="cov0" title="0">{
        go lightnode.updater.Run(ctx)
        go lightnode.validator.Run(ctx)
        go lightnode.cacher.Run(ctx)
        go lightnode.dispatcher.Run(ctx)

        lightnode.server.Run()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package ratelimiter

import (
        "github.com/renproject/darknode/jsonrpc"
)

// A RateLimiter handles the rate limiting logic for JSON-RPC requests. Each
// different type of JSON-RPC method has an independent rate limit.
type RateLimiter struct {
        limiters map[string]*jsonrpc.RateLimiter
}

// New constructs a new `RateLimiter`.
func New() RateLimiter <span class="cov0" title="0">{
        limiters := map[string]*jsonrpc.RateLimiter{}

        // TODO: Currently this uses the same rate limits as the darknode, but
        // since the lightnode sends requests to many darknodes, these rate limits
        // should be different (but still dependent on the darknode limits).
        for method, rpc := range jsonrpc.RPCs </span><span class="cov0" title="0">{
                limiters[method] = rpc.RateLimiter
        }</span>

        <span class="cov0" title="0">return RateLimiter{limiters}</span>
}

// Allow updates and checks the rate limiting for a given IP address and
// JSON-RPC method. A return value of false indicates that the rate limit has
// been exceeded. It will also return false if the method is not supported
// (i.e. unsupported methods have rate limits of 0/s).
func (rl *RateLimiter) Allow(method, addr string) bool <span class="cov0" title="0">{
        limiter, ok := rl.limiters[method]
        if !ok </span><span class="cov0" title="0">{
                // NOTE: This return value hides the fact that the method is not
                // supported. The fact that the method is not supported should be
                // checked elsewhere and suitable indication that this is the case
                // should be provided.
                return false
        }</span>
        <span class="cov0" title="0">return limiter.IPAddressLimiter(addr).Allow()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package server

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/gorilla/mux"
        "github.com/renproject/darknode/jsonrpc"
        "github.com/renproject/lightnode/server/ratelimiter"
        "github.com/renproject/phi"
        "github.com/rs/cors"
        "github.com/sirupsen/logrus"
)

var (
        // ErrorCodeMaxBatchSizeExceeded is an implemementation specific error code
        // that indicates that the maximum batch size has been exceeded.
        ErrorCodeMaxBatchSizeExceeded = -32001

        // ErrorCodeRateLimitExceeded is an implementation specific error code that
        // indicates that the client has been rate limited.
        ErrorCodeRateLimitExceeded = -32002

        // ErrorCodeForwardingError is an implementation specific error code that
        // indicates that a http error occurred when forwarding a request to a
        // darknode.
        ErrorCodeForwardingError = -32003

        // ErrorCodeInvalidParams is ann implementation specific error code that
        // indicates that a request object has invalid parameters.
        ErrorCodeInvalidParams = -32004
)

// Options are used when constructing a `Server`.
type Options struct {
        // Maximum JSON-RPC batch size that will be accepted.
        MaxBatchSize int
}

// Server defines the HTTP server for the lightnode.
type Server struct {
        port        string
        logger      logrus.FieldLogger
        options     Options
        rateLimiter ratelimiter.RateLimiter
        validator   phi.Sender
}

// New constructs a new `Server` with the given options.
func New(logger logrus.FieldLogger, port string, options Options, validator phi.Sender) *Server <span class="cov8" title="1">{
        rateLimiter := ratelimiter.New()
        return &amp;Server{
                port,
                logger,
                options,
                rateLimiter,
                validator,
        }
}</span>

// Run starts the `Server` listening on its port. This function is blocking.
func (server *Server) Run() <span class="cov8" title="1">{
        r := mux.NewRouter()
        r.HandleFunc("/", server.handleFunc)

        httpHandler := cors.New(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowCredentials: true,
                AllowedMethods:   []string{"POST"},
        }).Handler(r)

        // Start running the server.
        server.logger.Infof("lightnode listening on 0.0.0.0:%v...", server.port)
        http.ListenAndServe(fmt.Sprintf(":%s", server.port), httpHandler)
}</span>

func (server *Server) handleFunc(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        rawMessage := json.RawMessage{}
        if err := json.NewDecoder(r.Body).Decode(&amp;rawMessage); err != nil </span><span class="cov0" title="0">{
                err := jsonrpc.NewError(jsonrpc.ErrorCodeInvalidJSON, "lightnode could not decode JSON request", json.RawMessage{})
                response := jsonrpc.NewResponse(0, nil, &amp;err)
                server.writeResponses(w, []jsonrpc.Response{response})
                return
        }</span>
        // Unmarshal requests with support for batching
        <span class="cov8" title="1">reqs := []jsonrpc.Request{}
        if err := json.Unmarshal(rawMessage, &amp;reqs); err != nil </span><span class="cov8" title="1">{
                // If we fail to unmarshal the raw message into a list of JSON-RPC 2.0
                // requests, try to unmarshal the raw messgae into a single JSON-RPC 2.0
                // request
                var req jsonrpc.Request
                if err := json.Unmarshal(rawMessage, &amp;req); err != nil </span><span class="cov0" title="0">{
                        err := jsonrpc.NewError(jsonrpc.ErrorCodeInvalidJSON, "lightnode could not parse JSON request", json.RawMessage{})
                        response := jsonrpc.NewResponse(0, nil, &amp;err)
                        server.writeResponses(w, []jsonrpc.Response{response})
                        return
                }</span>
                <span class="cov8" title="1">reqs = []jsonrpc.Request{req}</span>
        }

        // Check that batch size does not exceed the maximum allowed batch size
        <span class="cov8" title="1">batchSize := len(reqs)
        if batchSize &gt; server.options.MaxBatchSize </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("maximum batch size exceeded: maximum is %v but got %v", server.options.MaxBatchSize, batchSize)
                err := jsonrpc.NewError(ErrorCodeMaxBatchSizeExceeded, errMsg, json.RawMessage{})
                response := jsonrpc.NewResponse(0, nil, &amp;err)
                server.writeResponses(w, []jsonrpc.Response{response})
                return
        }</span>

        // Handle all requests concurrently and, after all responses have been
        // received, write all responses back to the http.ResponseWriter
        <span class="cov8" title="1">responses := make([]jsonrpc.Response, len(reqs))
        phi.ParForAll(reqs, func(i int) </span><span class="cov8" title="1">{
                method := reqs[i].Method
                if !server.rateLimiter.Allow(method, r.RemoteAddr) </span><span class="cov0" title="0">{
                        err := jsonrpc.NewError(ErrorCodeRateLimitExceeded, "rate limit exceeded", json.RawMessage{})
                        response := jsonrpc.NewResponse(0, nil, &amp;err)
                        server.writeResponses(w, []jsonrpc.Response{response})
                        return
                }</span>

                <span class="cov8" title="1">reqWithResponder := NewRequestWithResponder(reqs[i])
                server.validator.Send(reqWithResponder)
                responses[i] = &lt;-reqWithResponder.Responder</span>
        })

        <span class="cov8" title="1">server.writeResponses(w, responses)</span>
}

func (server *Server) writeResponses(w http.ResponseWriter, responses []jsonrpc.Response) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        if len(responses) == 1 </span><span class="cov8" title="1">{
                if err := json.NewEncoder(w).Encode(responses[0]); err != nil </span><span class="cov0" title="0">{
                        server.logger.Errorf("error writing http response: %v", err)
                        return
                }</span>
        }
        <span class="cov8" title="1">if err := json.NewEncoder(w).Encode(responses); err != nil </span><span class="cov0" title="0">{
                server.logger.Errorf("error writing http response: %v", err)
                return
        }</span>
}

// RequestWithResponder wraps a `jsonrpc.Request` with a responder channel that
// the response will be written to.
type RequestWithResponder struct {
        Request   jsonrpc.Request
        Responder chan jsonrpc.Response
}

// IsMessage implements the `phi.Message` interface.
func (RequestWithResponder) IsMessage() {<span class="cov0" title="0">}</span>

// NewRequestWithResponder constructs a new request wrapper object.
func NewRequestWithResponder(req jsonrpc.Request) RequestWithResponder <span class="cov8" title="1">{
        responder := make(chan jsonrpc.Response, 1)
        return RequestWithResponder{req, responder}
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package store

import (
        "math/rand"

        "github.com/renproject/darknode/addr"
        "github.com/renproject/kv/db"
)

// MultiAddrStore is a store of `addr.MultiAddress`es.
type MultiAddrStore struct {
        store db.Iterable
}

// New constructs a new `MultiAddrStore`.
func New(store db.Iterable) MultiAddrStore <span class="cov0" title="0">{
        return MultiAddrStore{store}
}</span>

// Insert puts the given multi address into the store.
func (multiStore *MultiAddrStore) Insert(addr addr.MultiAddress) error <span class="cov0" title="0">{
        // TODO: What is a better key/value pair to store?
        return multiStore.store.Insert(addr.String(), []byte(addr.String()))
}</span>

// Delete removes the given multi address from the store.
func (multiStore *MultiAddrStore) Delete(addr addr.MultiAddress) <span class="cov0" title="0">{
        // NOTE: The `Delete` function always returns a nil error, so we ignore it.
        _ = multiStore.store.Delete(addr.String())
}</span>

// Size returns the number of entries in the store.
func (multiStore *MultiAddrStore) Size() int <span class="cov0" title="0">{
        size, err := multiStore.store.Size()
        if err != nil </span><span class="cov0" title="0">{
                // TODO: Is it ok to panic here?
                panic("[store] could not get size of store")</span>
        }
        <span class="cov0" title="0">return size</span>
}

// AddrsAll returns all of the multi addressses that are currently in the
// store.
func (multiStore *MultiAddrStore) AddrsAll() addr.MultiAddresses <span class="cov0" title="0">{
        addrs := addr.MultiAddresses{}
        for iter := multiStore.store.Iterator(); iter.Next(); </span><span class="cov0" title="0">{
                str, err := iter.Key()
                if err != nil </span><span class="cov0" title="0">{
                        panic("iterator invariant violated")</span>
                }
                <span class="cov0" title="0">address, err := addr.NewMultiAddressFromString(str)
                if err != nil </span><span class="cov0" title="0">{
                        panic("incorrectly stored multi address")</span>
                }
                <span class="cov0" title="0">addrs = append(addrs, address)</span>
        }

        <span class="cov0" title="0">return addrs</span>
}

// AddrsRandom returns a random number of addresses from the store.
func (multiStore *MultiAddrStore) AddrsRandom(n int) addr.MultiAddresses <span class="cov0" title="0">{
        addrs := multiStore.AddrsAll()

        rand.Shuffle(len(addrs), func(i, j int) </span><span class="cov0" title="0">{
                addrs[i], addrs[j] = addrs[j], addrs[i]
        }</span>)

        <span class="cov0" title="0">if len(addrs) &lt; n </span><span class="cov0" title="0">{
                return addrs
        }</span>
        <span class="cov0" title="0">return addrs[:n]</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package updater

import (
        "context"
        "encoding/json"
        "math/rand"
        "time"

        "github.com/renproject/darknode/addr"
        "github.com/renproject/darknode/jsonrpc"
        "github.com/renproject/darknode/p2p"
        "github.com/renproject/lightnode/client"
        "github.com/renproject/lightnode/store"
        "github.com/renproject/phi"
        "github.com/sirupsen/logrus"
)

// An Updater is a task responsible for querying the darknodes periodically to
// know which darknodes are in the network. It does this by requesting the
// peers of a random subset of the already known darknodes and adding any new
// darknodes to a store. This store is shared by the `Dispatcher`, which needs
// to know about the darknodes in the network.
type Updater struct {
        logger     logrus.FieldLogger
        multiStore store.MultiAddrStore
        pollRate   time.Duration
        timeout    time.Duration
}

// New constructs a new `Updater`. If the given store of multi addresses is
// empty, then the constructed `Updater` will be useless since it will not know
// any darknodes to query. Therefore the given store must contain some number
// of bootstrap addresses.
func New(logger logrus.FieldLogger, multiStore store.MultiAddrStore, pollRate, timeout time.Duration) Updater <span class="cov8" title="1">{
        return Updater{
                logger:     logger,
                multiStore: multiStore,
                pollRate:   pollRate,
                timeout:    timeout,
        }
}</span>

// Run starts the `Updater` making requests to the darknodes and updating its
// store. This function is blocking.
func (updater *Updater) Run(ctx context.Context) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        updater.updateMultiAddress()
                        time.Sleep(updater.pollRate)</span>
                }
        }
}

func (updater *Updater) updateMultiAddress() <span class="cov8" title="1">{
        params, err := json.Marshal(jsonrpc.ParamsQueryPeers{})
        if err != nil </span><span class="cov0" title="0">{
                updater.logger.Errorf("cannot marshal query peers params: %v", err)
                return
        }</span>

        <span class="cov8" title="1">addrs := updater.getQueryAddresses()

        phi.ParForAll(addrs, func(i int) </span><span class="cov8" title="1">{
                multi := addrs[i]

                // Send request to the node to retrieve its peers.
                request := jsonrpc.Request{
                        Version: "2.0",
                        ID:      rand.Int31(),
                        Method:  jsonrpc.MethodQueryPeers,
                        Params:  params,
                }
                response, err := client.SendToDarknode(client.URLFromMulti(multi), request, updater.timeout)

                // TODO: Maybe we shouldn't always delete an address when we can't
                // query it; probably put some more intelligent logic here.
                if err != nil </span><span class="cov0" title="0">{
                        updater.logger.Warnf("[updater] cannot connect to node %v: %v", multi.String(), err)
                        updater.multiStore.Delete(multi)
                        return
                }</span>

                // Parse the response and write any multi-addresses returned by the node to the store.
                <span class="cov8" title="1">raw, err := json.Marshal(response.Result)
                if err != nil </span><span class="cov0" title="0">{
                        updater.logger.Panicf("[updater] error marshaling and already unmarshaled result: %v", err)
                }</span>
                <span class="cov8" title="1">var resp p2p.QueryPeersResponse
                err = json.Unmarshal(raw, &amp;resp)
                if err != nil </span><span class="cov0" title="0">{
                        updater.logger.Panicf("[updater] could not unmarshal into expected result type: %v", err)
                }</span>
                <span class="cov8" title="1">for _, multiAddr := range resp.MultiAddresses </span><span class="cov8" title="1">{
                        if err := updater.multiStore.Insert(multiAddr); err != nil </span><span class="cov0" title="0">{
                                updater.logger.Errorf("cannot add multi-address to store: %v", err)
                                return
                        }</span>
                }
        })
}

func (updater *Updater) getQueryAddresses() addr.MultiAddresses <span class="cov8" title="1">{
        // TODO: Should this be a constant number of random addresses always? If
        // so, is this the right constant?
        return updater.multiStore.AddrsRandom(3)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package validator

import (
        "encoding/json"
        "fmt"

        "github.com/renproject/darknode/jsonrpc"
        "github.com/renproject/lightnode/server"
        "github.com/renproject/phi"
        "github.com/sirupsen/logrus"
)

// A Validator takes as input requests and checks whether they meet some
// baseline criteria that the darknodes expect. This means that obviously
// invalid requests will not make it to the darknodes, but not all invalid
// requests will get rejected.
type Validator struct {
        logger logrus.FieldLogger
        cacher phi.Sender
}

// New constructs a new `Validator`.
func New(cacher phi.Sender, logger logrus.FieldLogger, opts phi.Options) phi.Task <span class="cov8" title="1">{
        return phi.New(&amp;Validator{logger, cacher}, opts)
}</span>

// Handle implements the `phi.Handler` interface.
func (validator *Validator) Handle(_ phi.Task, message phi.Message) <span class="cov8" title="1">{
        msg, ok := message.(server.RequestWithResponder)
        if !ok </span><span class="cov0" title="0">{
                validator.logger.Panicf("[validator] unexpected message type %T", message)
        }</span>

        <span class="cov8" title="1">if err := isValid(msg.Request); err != nil </span><span class="cov8" title="1">{
                msg.Responder &lt;- jsonrpc.NewResponse(msg.Request.ID, nil, err)
                return
        }</span>
        <span class="cov8" title="1">validator.cacher.Send(msg)</span>
}

func isValid(message jsonrpc.Request) *jsonrpc.Error <span class="cov8" title="1">{
        // Reject requests that don't conform to the JSON-RPC standard
        if message.Version != "2.0" </span><span class="cov8" title="1">{
                err := jsonrpc.NewError(jsonrpc.ErrorCodeInvalidRequest, fmt.Sprintf("invalid jsonrpc field: expected \"2.0\", got \"%s\"", message.Version), json.RawMessage{})
                return &amp;err
        }</span>

        // Reject unsupported methods
        <span class="cov8" title="1">method := message.Method
        if !isSupported(method) </span><span class="cov8" title="1">{
                err := jsonrpc.NewError(jsonrpc.ErrorCodeMethodNotFound, fmt.Sprintf("unsupported method %s", method), json.RawMessage{})
                return &amp;err
        }</span>

        // Reject requests with invalid parameters
        <span class="cov8" title="1">if ok, msg := hasValidParams(message); !ok </span><span class="cov8" title="1">{
                err := jsonrpc.NewError(server.ErrorCodeInvalidParams, fmt.Sprintf("invalid parameters in request: %s", msg), json.RawMessage{})
                return &amp;err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func isSupported(method string) bool <span class="cov8" title="1">{
        _, supported := jsonrpc.RPCs[method]
        return supported
}</span>

func hasValidParams(message jsonrpc.Request) (bool, string) <span class="cov8" title="1">{
        switch message.Method </span>{
        case jsonrpc.MethodQueryBlock:<span class="cov8" title="1">
                if len(message.Params) != 0 </span><span class="cov8" title="1">{
                        return false, "parameters object does not match method"
                }</span>
                <span class="cov8" title="1">return validQueryBlockParams(message.Params)</span>
        case jsonrpc.MethodQueryBlocks:<span class="cov8" title="1">
                if len(message.Params) != 0 </span><span class="cov8" title="1">{
                        return false, "parameters object does not match method"
                }</span>
                <span class="cov8" title="1">return validQueryBlocksParams(message.Params)</span>
        case jsonrpc.MethodSubmitTx:<span class="cov8" title="1">
                var params jsonrpc.ParamsSubmitTx
                if err := json.Unmarshal(message.Params, &amp;params); err != nil </span><span class="cov8" title="1">{
                        return false, "parameters object does not match method"
                }</span>
                <span class="cov8" title="1">return validSubmitTxParams(params)</span>
        case jsonrpc.MethodQueryTx:<span class="cov8" title="1">
                var params jsonrpc.ParamsQueryTx
                if err := json.Unmarshal(message.Params, &amp;params); err != nil </span><span class="cov8" title="1">{
                        return false, "parameters object does not match method"
                }</span>
                <span class="cov8" title="1">return validQueryTxParams(params)</span>
        case jsonrpc.MethodQueryNumPeers:<span class="cov8" title="1">
                if len(message.Params) != 0 </span><span class="cov8" title="1">{
                        return false, "parameters object does not match method"
                }</span>
                <span class="cov8" title="1">return validQueryNumPeersParams(message.Params)</span>
        case jsonrpc.MethodQueryPeers:<span class="cov8" title="1">
                if len(message.Params) != 0 </span><span class="cov8" title="1">{
                        return false, "parameters object does not match method"
                }</span>
                <span class="cov8" title="1">return validQueryPeersParams(message.Params)</span>
        case jsonrpc.MethodQueryEpoch:<span class="cov0" title="0">
                // TODO: At the time of writing this method is not supported by the
                // darknode. This should be implemented once it is implemented in the
                // darknode.
                return false, "method QueryEpoch is not supported"</span>
        case jsonrpc.MethodQueryStat:<span class="cov8" title="1">
                if len(message.Params) != 0 </span><span class="cov8" title="1">{
                        return false, "parameters object does not match method"
                }</span>
                <span class="cov8" title="1">return validQueryStatParams(message.Params)</span>
        default:<span class="cov0" title="0">
                // TODO: Is it ok to panic at this level, or should all panics happen
                // through a logger?
                panic(fmt.Sprintf("[validator] unsupported method %s encountered which should have been rejected by the previous checks", message.Method))</span>
        }
}

func validQueryBlockParams(params json.RawMessage) (bool, string) <span class="cov8" title="1">{
        // This parameter type has no fields, so there is nothing to check.
        return true, ""
}</span>

func validQueryBlocksParams(params json.RawMessage) (bool, string) <span class="cov8" title="1">{
        // This parameter type has no fields, so there is nothing to check.
        return true, ""
}</span>

func validSubmitTxParams(params jsonrpc.ParamsSubmitTx) (bool, string) <span class="cov8" title="1">{
        // TODO: Check fields. Do we want to use the entire darknode transform
        // pipeline to check validity?
        return true, ""
}</span>

func validQueryTxParams(params jsonrpc.ParamsQueryTx) (bool, string) <span class="cov8" title="1">{
        // Currently the only field in the parameters is a hash field, which can't
        // really be checked for validity here
        return true, ""
}</span>

func validQueryNumPeersParams(params json.RawMessage) (bool, string) <span class="cov8" title="1">{
        // This parameter type has no fields, so there is nothing to check.
        return true, ""
}</span>

func validQueryPeersParams(params json.RawMessage) (bool, string) <span class="cov8" title="1">{
        // This parameter type has no fields, so there is nothing to check.
        return true, ""
}</span>

func validQueryStatParams(params json.RawMessage) (bool, string) <span class="cov8" title="1">{
        // This parameter type has no fields, so there is nothing to check.
        return true, ""
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
